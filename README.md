# Утилита для буферизации пайпов в ФС [![Build Status](https://secure.travis-ci.org/avz/buf.png)](http://travis-ci.org/avz/buf)

Утилита позволяет сохранять в ФС содержимое unix-пайпа для дальнейшей обработки сторонним процессом.

Это может быть полезно, если не желательно тормозить процесс-генератор в условиях, когда приёмник данных
не успевает обрабатывать эти данные.

Логика работу разбита на два процесса: процесс-писатель и процесс-читатель.
Первый процесс читает данные со стандартного потока ввода (``STDIN``) и записывает их в ФС.
Второй процесс читает данные, записанные в ФС писателем, и пишет их в стандартный поток вывода (``STDOUT``).

Запись и чтение могут происходить параллельно. Например, если запустить запись, подождать накопления
некоторого количетсва данных, а потом запустить чтение, то утилита прочитает все сохранённые данные,
тем самым догнав писателя (конечно, если читатель будет читать быстрее, чем пишет писатель), а после
этого будет продолжать чтение уже в реальном времени со скоростью записи.

Читатель завершит работу только когда обработает все данные и только при условии, что писатель уже завершил работу.

```
% cat /dev/random | buf -w /tmp/random
```

```
% buf -r /tmp/random | hexdump -C
```
## Установка

```
# git clone https://github.com/avz/buf.git
# cd buf
# sudo make install
```

или однострочник

```
cd /tmp && git clone https://github.com/avz/buf.git && cd buf && sudo make install
```

## Использование

```
buf -r [-mp] /path/to/storage/dir
buf -w [ -s bytes ][ -t seconds ][-cl] /path/to/storage/dir
```

``/path/to/storage/dir`` - путь, по которому будет создан каталог с данными.
На момент запуска не должен существовать

 * ``-w`` работать в режиме записи на диск
   * ``-s bytes`` максимальный размер файла данных при сохранении. При достижении лимита будет создан новый файл. По умолчанию - 1MiB (1024 * 1024 байт)
   * ``-t seconds`` создавать новый файл данных не реже ``seconds`` секунд. По умолчанию отключено
   * ``-c`` если каталог потока уже создан, то продолжить писать в него. Допускается только один писатель на каталог
   * ``-l`` режим, при котором входной поток интерпретируется как набор строк, в этом режиме строка не может быть порезана на части и помещена в разные чанки, что позволяет эффективно распараллелить обработку отдельных строк между несколькими читателями (см. опцию ``-m`` в режиме чтения)
 * ``-r`` работать в режиме чтения с диска
   * ``-m`` допускать обработку одного потока несколькими читателями. Один чанк обрабатывается только одним потоком, поэтому желательно подбирать размер чанка под задачу. Все читатели должны быть запущены с этой опцией
   * ``-p`` включит persistent mode. В этом режиме читатель не завершает работу после полной обработки, а ждёт появления нового писателя. Читатель завершит работу только если каталог с потоком будет удалён

## Технические детали

### Режим записи
Поток сохраняется в указанном каталоге в файлах-чанках.
При достижении заданного размера (опция ``-s``) создаётся новый чанк и запись продолжается уже в него. Кроме того, если указана
опция ``-t``, то чанки будут дополнительно создаваться примерно раз в столько секунд.
Допускается использование обеих опций одновременно, тогда новые чанки создаются и по времени и по размеру.
Названия файлов содержат в себе номер чанка в потоке и начинаются с 1:
```
0000000001.chunk
0000000002.chunk
...
0000100500.chunk
```

### Режим чтения
В режиме чтения утилита сканирует указанный каталог, находит в нём первый чанк и читает их по порядку.
По окончании чанка он удаляется из ФС. Если чанков больше нет и в этот каталог в настощее время не идёт запись, то каталог удаляется.

Если остановить утилиту, не дождавшись полной обработки потока,
то **при следующем запуске чтение будет продолжено с начала чанка, который обработывался в момент остановки**,
то есть в этом случае возможна повторная обработка тех данных.
По этой причине рекомендуется не допускать завершения работы пока все данные не будут обработаны, либо,
если повторы не очень критичны, можно просто уменьшить размер чанка или добавить создание по времени.
